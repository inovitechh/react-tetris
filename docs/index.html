<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="React Tetris - Dokunmatik kontrollü Tetris oyunu" />
    <title>React Tetris</title>
    <style>
      :root { --bg1:#667eea; --bg2:#764ba2; --panel:rgba(255,255,255,.1); }
      *{margin:0;padding:0;box-sizing:border-box;touch-action:manipulation}
      body{min-height:100vh;background:linear-gradient(135deg,var(--bg1),var(--bg2));
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial}
      .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px}
      .card{background:var(--panel);backdrop-filter:blur(6px);border-radius:16px;padding:16px;display:flex;gap:16px;align-items:center;flex-direction:column;max-width:900px;width:100%}
      canvas{background:#0e1323;border-radius:8px;image-rendering:pixelated;image-rendering:crisp-edges;width:min(88vw,220px);height:auto}
      .pad{width:min(88vw,220px);display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:8px;margin-top:10px}
      .actions{width:min(88vw,220px);display:flex;gap:8px;margin-top:8px}
      .actions button{flex:1 1 50%;padding:12px 0;border:0;border-radius:12px;font-weight:700}
      #start2{background:#ff6b6b;color:#fff}
      #padDrop{background:#4dabf7;color:#fff}
      .pad button{padding:14px 0;border:0;border-radius:12px;background:#ffffff1a;border:1px solid #ffffff22;color:#fff;font-weight:700}
      .pad .blank{visibility:hidden}
      .side{min-width:0;color:#fff;width:100%}
      .preview{background:var(--panel);border-radius:12px;padding:6px;margin:6px 0;display:flex;align-items:center;justify-content:center}
      .preview canvas{background:rgba(14,19,35,.45);border-radius:8px;image-rendering:pixelated}
      .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
      .controls button{flex:1 1 calc(50% - 8px);background:#ffffff1a;border:1px solid #ffffff22;color:#fff}
      .controls .wide{flex-basis:100%;background:#4dabf7}
      h1{font-size:18px;margin-bottom:8px}
      .stat{background:var(--panel);padding:8px 10px;border-radius:10px;margin-bottom:8px}
      button{width:100%;padding:12px 14px;border:0;border-radius:10px;background:#ff6b6b;color:#fff;font-weight:700;cursor:pointer}
      .keys{margin-top:8px;font-size:12px;opacity:.85}
      @media (min-width:640px){
        .card{flex-direction:row;align-items:flex-start;justify-content:center}
        canvas{width:220px}
        .pad{width:220px}
        .actions{width:220px}
        .side{max-width:160px}
      }
      @media (min-width:1024px){
        canvas{width:240px}
        .pad{width:240px}
        .actions{width:240px}
        .side{max-width:180px}
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <canvas id="tetris" width="200" height="400"></canvas>
        <div class="pad" id="dpad">
          <button class="blank"></button>
          <button id="padUp">▲</button>
          <button class="blank"></button>
          <button id="padLeft">◀</button>
          <button id="padRotate">⟳</button>
          <button id="padRight">▶</button>
          <button class="blank"></button>
          <button id="padDown">▼</button>
          <button class="blank"></button>
        </div>
        <div class="actions">
          <button id="start2">Oyunu Başlat</button>
          <button id="padDrop">Hızlı İndir</button>
        </div>
        <div class="side">
          <h1>Mobile Tetris</h1>
          <div class="stat">Skor: <b id="score">0</b></div>
          <div class="stat">Seviye: <b id="level">1</b></div>
          <div class="stat">Satır: <b id="lines">0</b></div>
          <div class="preview"><canvas id="nextCanvas" width="64" height="64"></canvas></div>
          <button id="start">Oyunu Başlat</button>
          <div class="controls" id="touchControls">
            <button id="btnLeft">◀ Sol</button>
            <button id="btnRight">Sağ ▶</button>
            <button id="btnRotate">⟳ Döndür</button>
            <button id="btnDown">▼ Aşağı</button>
            <button class="wide" id="btnDrop">⬇ Hard Drop</button>
          </div>
          <div class="keys">Ok tuşları: hareket / Yukarı: döndür / Aşağı: hızlı düşür / Boşluk: hard drop</div>
        </div>
      </div>
    </div>
  <script>
    // Basit HTML5 Tetris (frameworksüz)
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const COLS = 10, ROWS = 20, SIZE = 20;
    canvas.width = COLS * SIZE; canvas.height = ROWS * SIZE; ctx.scale(SIZE, SIZE);
    const COLORS = { I:'#00e5ff', J:'#4263eb', L:'#f59f00', O:'#ffd43b', S:'#51cf66', T:'#845ef7', Z:'#ff6b6b' };
    const SHAPES = {
      I:[[1,1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0]], T:[[0,1,0],[1,1,1]], Z:[[1,1,0],[0,1,1]]
    };
    const board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    const nextCtx = document.getElementById('nextCanvas').getContext('2d');
    let current=null,next=null,pos={x:0,y:0},rot=0,score=0,level=1,lines=0,dropTimer=0,dropInterval=1000,running=false;
    const $ = id=>document.getElementById(id);
    function randPiece(){ const t=Object.keys(SHAPES)[Math.floor(Math.random()*7)]; return {type:t, shape:SHAPES[t], color:COLORS[t]}; }
    const rot90 = m => m[0].map((_,i)=>m.map(r=>r[i]).reverse());
    const shape = () => { let s=current.shape; for(let i=0;i<rot;i++) s=rot90(s); return s; };
    function collide(nx=pos.x, ny=pos.y, s=shape()){
      for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){
        const yy=ny+y, xx=nx+x; if(xx<0||xx>=COLS||yy>=ROWS|| (yy>=0 && board[yy][xx])) return true;
      } return false;
    }
    function merge(){ const s=shape(); for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){ const yy=pos.y+y, xx=pos.x+x; if(yy>=0) board[yy][xx]=current.color; } }
    function clearLines(){ let c=0; for(let y=ROWS-1;y>=0;y--) if(board[y].every(Boolean)){ board.splice(y,1); board.unshift(Array(COLS).fill(0)); c++; y++; }
      if(c){ lines+=c; score+=c*100*level; level=Math.floor(lines/10)+1; dropInterval=Math.max(100,1000-(level-1)*100); updateHud(); }
    }
    function spawn(){
      current = next || randPiece();
      next = randPiece();
      rot = 0;
      pos.x = Math.floor((COLS - shape()[0].length)/2);
      pos.y = -2;
      drawNext();
      if(collide(pos.x,pos.y)) running=false;
    }
    function drawCell(x,y,c){ ctx.fillStyle=c; ctx.fillRect(x,y,1,1); ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=0.05; ctx.strokeRect(x,y,1,1); }
    function draw(){
      ctx.clearRect(0,0,COLS,ROWS);
      // board background subtle tint
      ctx.fillStyle='rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,COLS,ROWS);
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawCell(x,y,board[y][x]);
      // ghost piece
      if(current){
        const s=shape();
        let gy=pos.y;
        while(!collide(pos.x,gy+1,s)) gy++;
        // draw ghost
        ctx.globalAlpha=0.25;
        for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){ const yy=gy+y; if(yy>=0) drawCell(pos.x+x,yy,current.color); }
        ctx.globalAlpha=1;
        // draw active
        for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){ const yy=pos.y+y; if(yy>=0) drawCell(pos.x+x,yy,current.color); }
      }
    }
    function update(t){ if(!running){ draw(); return; } if(!dropTimer) dropTimer=t; if(t-dropTimer>dropInterval){ drop(); dropTimer=t; } draw(); requestAnimationFrame(update); }
    const drop=()=> !collide(pos.x,pos.y+1) ? (pos.y++) : (merge(),clearLines(),spawn());
    const move=dx=>{ if(!collide(pos.x+dx,pos.y)) pos.x+=dx; };
    const rotCW=()=>{ const old=rot; rot=(rot+1)%4; if(collide()) rot=old; };
    const hardDrop=()=>{ while(!collide(pos.x,pos.y+1)) pos.y++; merge(); clearLines(); spawn(); };
    function updateHud(){ $('score').textContent=score; $('level').textContent=level; $('lines').textContent=lines; }
    function drawNext(){
      nextCtx.clearRect(0,0,64,64);
      if(!next) return;
      let s = next.shape;
      // center piece in 4x4 box (smaller preview)
      const cell = 14; // px per cell inside preview
      // compute offsets
      const w = s[0].length, h = s.length;
      const startX = Math.floor((64/cell - w)/2);
      const startY = Math.floor((64/cell - h)/2);
      for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(s[y][x]){
        nextCtx.fillStyle = next.color;
        nextCtx.fillRect((startX+x)*cell,(startY+y)*cell,cell,cell);
        nextCtx.strokeStyle = 'rgba(0,0,0,.25)';
        nextCtx.lineWidth = 1;
        nextCtx.strokeRect((startX+x)*cell,(startY+y)*cell,cell,cell);
      }
    }
    function startGame(){ if(running) return; board.forEach(r=>r.fill(0)); score=0; level=1; lines=0; updateHud(); next=randPiece(); drawNext(); spawn(); running=true; dropTimer=0; requestAnimationFrame(update); }
    $('start').onclick=startGame;
    const s2=document.getElementById('start2'); if(s2) s2.onclick=startGame;
    window.addEventListener('keydown',e=>{ if(!running) return; if(e.key==='ArrowLeft') move(-1); else if(e.key==='ArrowRight') move(1); else if(e.key==='ArrowUp') rotCW(); else if(e.key==='ArrowDown') drop(); else if(e.code==='Space') hardDrop(); });
    // Touch controls (mobile)
    const bindTap=(id,fn)=>{ const el=document.getElementById(id); if(!el) return; const h=e=>{ e.preventDefault(); if(running) fn(); }; el.addEventListener('click',h); el.addEventListener('touchstart',h,{passive:false}); };
    bindTap('btnLeft',()=>move(-1));
    bindTap('btnRight',()=>move(1));
    bindTap('btnRotate',()=>rotCW());
    bindTap('btnDown',()=>drop());
    bindTap('btnDrop',()=>hardDrop());
    // D-pad bindings
    bindTap('padLeft',()=>move(-1));
    bindTap('padRight',()=>move(1));
    bindTap('padUp',()=>rotCW());
    bindTap('padDown',()=>drop());
    bindTap('padDrop',()=>hardDrop());
    draw();
  </script>
</body>
</html>



