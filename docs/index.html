<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="React Tetris - Dokunmatik kontrollü Tetris oyunu" />
    <title>React Tetris</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: manipulation;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        overflow-x: hidden;
      }
      
      #root {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="card">
        <canvas id="tetris" width="200" height="400"></canvas>
        <div class="side">
          <h1>Mobile Tetris</h1>
          <div class="stat">Skor: <b id="score">0</b></div>
          <div class="stat">Seviye: <b id="level">1</b></div>
          <div class="stat">Satır: <b id="lines">0</b></div>
          <button id="start">Oyunu Başlat</button>
          <div class="keys">Ok tuşları: hareket / Yukarı: döndür / Aşağı: hızlı düşür / Boşluk: hard drop</div>
        </div>
      </div>
    </div>
  <script>
    // Basit HTML5 Tetris (frameworksüz)
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const COLS = 10, ROWS = 20, SIZE = 20;
    canvas.width = COLS * SIZE; canvas.height = ROWS * SIZE; ctx.scale(SIZE, SIZE);
    const COLORS = { I:'#00e5ff', J:'#4263eb', L:'#f59f00', O:'#ffd43b', S:'#51cf66', T:'#845ef7', Z:'#ff6b6b' };
    const SHAPES = {
      I:[[1,1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0]], T:[[0,1,0],[1,1,1]], Z:[[1,1,0],[0,1,1]]
    };
    const board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    let current=null,next=null,pos={x:0,y:0},rot=0,score=0,level=1,lines=0,dropTimer=0,dropInterval=1000,running=false;
    const $ = id=>document.getElementById(id);
    function randPiece(){ const t=Object.keys(SHAPES)[Math.floor(Math.random()*7)]; return {type:t, shape:SHAPES[t], color:COLORS[t]}; }
    const rot90 = m => m[0].map((_,i)=>m.map(r=>r[i]).reverse());
    const shape = () => { let s=current.shape; for(let i=0;i<rot;i++) s=rot90(s); return s; };
    function collide(nx=pos.x, ny=pos.y, s=shape()){
      for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){
        const yy=ny+y, xx=nx+x; if(xx<0||xx>=COLS||yy>=ROWS|| (yy>=0 && board[yy][xx])) return true;
      } return false;
    }
    function merge(){ const s=shape(); for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){ const yy=pos.y+y, xx=pos.x+x; if(yy>=0) board[yy][xx]=current.color; } }
    function clearLines(){ let c=0; for(let y=ROWS-1;y>=0;y--) if(board[y].every(Boolean)){ board.splice(y,1); board.unshift(Array(COLS).fill(0)); c++; y++; }
      if(c){ lines+=c; score+=c*100*level; level=Math.floor(lines/10)+1; dropInterval=Math.max(100,1000-(level-1)*100); updateHud(); }
    }
    function spawn(){ current=next||randPiece(); next=randPiece(); rot=0; pos.x=Math.floor((COLS-shape()[0].length)/2); pos.y=-2; if(collide(pos.x,pos.y)) running=false; }
    function drawCell(x,y,c){ ctx.fillStyle=c; ctx.fillRect(x,y,1,1); ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=0.05; ctx.strokeRect(x,y,1,1); }
    function draw(){ ctx.clearRect(0,0,COLS,ROWS); for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawCell(x,y,board[y][x]);
      if(current){ const s=shape(); for(let y=0;y<s.length;y++) for(let x=0;x<s[y].length;x++) if(s[y][x]){ const yy=pos.y+y; if(yy>=0) drawCell(pos.x+x,yy,current.color); }} }
    function update(t){ if(!running){ draw(); return; } if(!dropTimer) dropTimer=t; if(t-dropTimer>dropInterval){ drop(); dropTimer=t; } draw(); requestAnimationFrame(update); }
    const drop=()=> !collide(pos.x,pos.y+1) ? (pos.y++) : (merge(),clearLines(),spawn());
    const move=dx=>{ if(!collide(pos.x+dx,pos.y)) pos.x+=dx; };
    const rotCW=()=>{ const old=rot; rot=(rot+1)%4; if(collide()) rot=old; };
    const hardDrop=()=>{ while(!collide(pos.x,pos.y+1)) pos.y++; merge(); clearLines(); spawn(); };
    function updateHud(){ $('score').textContent=score; $('level').textContent=level; $('lines').textContent=lines; }
    $('start').onclick=()=>{ if(running) return; board.forEach(r=>r.fill(0)); score=0; level=1; lines=0; updateHud(); next=randPiece(); spawn(); running=true; dropTimer=0; requestAnimationFrame(update); };
    window.addEventListener('keydown',e=>{ if(!running) return; if(e.key==='ArrowLeft') move(-1); else if(e.key==='ArrowRight') move(1); else if(e.key==='ArrowUp') rotCW(); else if(e.key==='ArrowDown') drop(); else if(e.code==='Space') hardDrop(); });
    draw();
  </script>
</body>
</html>



